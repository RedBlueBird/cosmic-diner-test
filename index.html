<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Diner: Terminal Simulation</title>
    <style>
        body {
            background-color: #0d1117;
            color: #33ff33;
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            padding: 20px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #terminal {
            width: 900px;
            height: 600px;
            border: 2px solid #33ff33;
            background-color: #000;
            display: grid;
            grid-template-columns: 250px 1fr 250px;
            grid-template-rows: 80px 1fr 150px;
            gap: 10px;
            padding: 10px;
            box-shadow: 0 0 20px rgba(51, 255, 51, 0.2);
            position: relative;
        }

        /* Scanlines */
        #terminal::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        /* Layout Areas */
        header {
            grid-column: 1 / -1;
            border-bottom: 1px dashed #33ff33;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 0 10px;
            font-weight: bold;
        }

        .header-top {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 5px;
        }

        /* Progress Bar */
        #progress-container {
            width: 100%;
            height: 15px;
            border: 1px solid #555;
            background-color: #111;
            position: relative;
        }

        #progress-bar {
            height: 100%;
            background-color: #33ff33;
            width: 0%;
            transition: width 0.3s;
        }
        
        #progress-text {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #000;
            line-height: 15px;
            font-weight: bold;
        }

        #left-panel {
            grid-column: 1;
            border-right: 1px dashed #33ff33;
            padding: 10px;
            overflow-y: auto;
        }

        #center-panel {
            grid-column: 2;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-y: auto;
        }

        #right-panel {
            grid-column: 3;
            border-left: 1px dashed #33ff33;
            padding: 10px;
            overflow-y: auto;
        }

        #log-panel {
            grid-column: 1 / -1;
            border-top: 1px dashed #33ff33;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.9em;
            color: #aaffaa;
        }

        /* UI Elements */
        .btn {
            background: transparent;
            border: 1px solid #33ff33;
            color: #33ff33;
            padding: 5px 10px;
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
            font-size: 0.85em;
        }
        .btn:hover {
            background: #33ff33;
            color: #000;
        }
        .btn:disabled {
            border-color: #555;
            color: #555;
            cursor: not-allowed;
        }

        .item-slot {
            display: flex;
            justify-content: space-between;
            padding: 2px 0;
            cursor: pointer;
        }
        .item-slot:hover {
            background-color: #113311;
        }
        .item-slot.selected {
            background-color: #33ff33;
            color: #000;
        }

        .ascii-art {
            white-space: pre;
            font-size: 10px;
            line-height: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        h3 { margin: 0 0 10px 0; border-bottom: 1px solid #555; padding-bottom: 5px; }

        .design-alert {
            color: #ff3333;
            font-weight: bold;
        }
        
        .game-over {
            color: #ff3333;
            font-weight: bold;
            font-size: 1.2em;
            text-align: center;
        }

        /* Modal Styles */
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #000;
            border: 2px solid #33ff33;
            padding: 20px;
            z-index: 10;
            width: 350px;
            max-height: 500px;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(51, 255, 51, 0.5);
            text-align: center;
        }
        .hidden { display: none; }
        .grid-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .sanity-critical { animation: pulse 1s infinite; }
        @keyframes pulse {
            0%, 100% { color: #ff3333; }
            50% { color: #ff9999; }
        }
    </style>
</head>
<body>

<div id="terminal">
    <header>
        <div class="header-top">
            <span>COSMIC DINER v0.1</span>
            <span>DAY: <span id="day-display">1</span> | RENT DUE: $<span id="rent-display">20</span></span>
        </div>
        <div id="progress-container">
            <div id="progress-bar"></div>
            <div id="progress-text">SHIFT PROGRESS</div>
        </div>
    </header>

    <div id="left-panel">
        <h3>STATUS</h3>
        <div>MONEY: $<span id="money">50</span></div>
        <div>SANITY: <span id="sanity">100</span>%</div>
        <br>
        <h3>COUNTERTOP (Storage)</h3>
        <div id="countertop-list">
            <!-- Items go here -->
        </div>
        <br>
        <button class="btn" onclick="game.clearSelection()">Deselect All</button>
    </div>

    <div id="center-panel">
        <div class="ascii-art" id="appliance-art">
   _____  
  |     | 
  |  P  | 
  |_____| 
   /   \  
        </div>
        
        <h3>KITCHEN APPLIANCES</h3>
        <div style="display: flex; flex-wrap: wrap; justify-content: center;">
            <button id="btn-fridge" class="btn" onclick="game.useFridge()" title="Withdraw an ingredient from your stock">[FRIDGE]</button>
            <button id="btn-pan" class="btn" onclick="game.usePan()" title="Combine two ingredients into a new dish">[PAN]</button>
            <button id="btn-board" class="btn" onclick="game.useBoard()" title="Break down a dish into its base ingredients">[BOARD]</button>
            <button id="btn-amp" class="btn" onclick="game.useAmp()" title="Amplify an ingredient into a different variant">[AMP]</button>
            <button id="btn-micro" class="btn" onclick="game.useMicrowave()" title="Mutate an ingredient with unpredictable results">[MICRO]</button>
            <button id="btn-trash" class="btn" onclick="game.useTrash()" title="Discard selected items from the countertop">[TRASH]</button>
        </div>

        <br>
        <h3>ACTIONS</h3>
        <div style="display: flex; flex-wrap: wrap; justify-content: center;">
            <button class="btn" onclick="game.tasteTest()" title="Analyze a dish's properties (costs 10 sanity)">[TASTE -10 S]</button>
            <button class="btn" onclick="game.serveCustomer()" title="Serve the prepared dish to the customer">[SERVE]</button>
        </div>
    </div>

    <div id="right-panel">
        <h3>CURRENT CUSTOMER</h3>
        <div id="customer-view">
            <pre id="customer-avatar">
   O
  /|\  
  / \
            </pre>
            <p id="customer-name" style="font-weight:bold;">Unknown</p>
            <p>"<span id="customer-quote">...</span>"</p>
            <p>ORDER: <span id="customer-order" style="color:#ffff00">???</span></p>
        </div>
    </div>

    <div id="log-panel">
        <div>> SYSTEM INITIALIZED...</div>
    </div>

    <!-- Modal for Fridge -->
    <div id="fridge-modal" class="modal hidden">
        <h3>FRIDGE STORAGE</h3>
        <div id="fridge-items" class="grid-buttons">
            <!-- Buttons injected here -->
        </div>
        <button class="btn" onclick="game.closeFridge()">[CLOSE]</button>
    </div>
</div>

<script>
/* EXPANDED GAME DATA & LOGIC */

// Food data will be loaded from external JSON file
let RECIPES = {};
let MUTATIONS = {};
let AMPLIFICATIONS = {};
let ATOMS = [];
let DEFAULT_ATTRIBUTES = {};
let FOOD_ATTRIBUTES = {};

// Legacy string attributes (kept for reference)
const ATTRIBUTES_LEGACY = {
    "Rice": ["Bland", "Filling"], "Meat": ["Raw", "Protein"], "Water": ["Wet", "Pure"],
    "Heat": ["Hot", "Burning"], "Bread": ["Bland", "Carbs"], "Pepper": ["Spicy", "Sharp"],
};

// Helper to create food attributes with defaults
function createFoodAttr(overrides) {
    return { ...DEFAULT_ATTRIBUTES, ...overrides };
}

// Load food data from JSON file
async function loadFoodData() {
    try {
        const response = await fetch('food-data.json');
        const data = await response.json();

        // Load base data
        RECIPES = data.recipes;
        MUTATIONS = data.mutations;
        AMPLIFICATIONS = data.amplifications;
        ATOMS = data.atoms;
        DEFAULT_ATTRIBUTES = data.defaultAttributes;

        // Build FOOD_ATTRIBUTES by applying defaults to each food's overrides
        FOOD_ATTRIBUTES = {};
        for (const [foodName, overrides] of Object.entries(data.foodAttributes)) {
            FOOD_ATTRIBUTES[foodName] = createFoodAttr(overrides);
        }

        // Merge mutations and amplifications into RECIPES for backward compatibility
        Object.assign(RECIPES, MUTATIONS);
        Object.assign(RECIPES, AMPLIFICATIONS);

        console.log('Food data loaded successfully');
        return true;
    } catch (error) {
        console.error('Failed to load food data:', error);
        return false;
    }
}

// Get attributes for any food item (with fallback for unknown items)
function getFoodAttributes(itemName) {
    if (FOOD_ATTRIBUTES[itemName]) {
        return FOOD_ATTRIBUTES[itemName];
    }
    // Fallback for dynamically created items (like "Hot X")
    if (itemName.startsWith("Hot ")) {
        const baseItem = itemName.substring(4);
        if (FOOD_ATTRIBUTES[baseItem]) {
            return { ...FOOD_ATTRIBUTES[baseItem], temperature: 8 };
        }
    }
    // Ultimate fallback - mysterious unknown food
    return createFoodAttr({
        sanity: -1, health: 2, filling: 3,
    });
}

// ============================================================================
// TASTE FEEDBACK SYSTEM
// Hardcoded messages for each attribute based on value ranges
// ============================================================================

const TASTE_FEEDBACK = {
    savory: [
        { min: 0, max: 0, msg: null },
        { min: 1, max: 3, msg: "A subtle hint of umami." },
        { min: 4, max: 6, msg: "Rich and savory." },
        { min: 7, max: 9, msg: "Deep, meaty richness fills your mouth." },
        { min: 10, max: Infinity, msg: "OVERWHELMING UMAMI BOMB." },
    ],
    sweet: [
        { min: 0, max: 0, msg: null },
        { min: 1, max: 3, msg: "A gentle sweetness." },
        { min: 4, max: 6, msg: "Pleasantly sweet." },
        { min: 7, max: 9, msg: "Very sweet, almost cloying." },
        { min: 10, max: Infinity, msg: "SUGAR OVERLOAD. Your teeth ache." },
    ],
    salty: [
        { min: 0, max: 0, msg: null },
        { min: 1, max: 3, msg: "Lightly salted." },
        { min: 4, max: 6, msg: "Well-seasoned with salt." },
        { min: 7, max: 9, msg: "Very salty. Your lips pucker." },
        { min: 10, max: Infinity, msg: "SALT CRYSTAL ASSAULT. Ocean incarnate." },
    ],
    sour: [
        { min: 0, max: 0, msg: null },
        { min: 1, max: 3, msg: "A slight tang." },
        { min: 4, max: 6, msg: "Pleasantly acidic." },
        { min: 7, max: 9, msg: "Sharp and tart. Face puckering." },
        { min: 10, max: Infinity, msg: "ACID ATTACK. Your enamel screams." },
    ],
    bitter: [
        { min: 0, max: 0, msg: null },
        { min: 1, max: 3, msg: "Slightly bitter undertones." },
        { min: 4, max: 6, msg: "Notable bitterness." },
        { min: 7, max: 9, msg: "Harsh and bitter. Coffee-like intensity." },
        { min: 10, max: Infinity, msg: "BITTER BEYOND REASON. Tastes like regret." },
    ],
    spicy: [
        { min: 0, max: 0, msg: null },
        { min: 1, max: 3, msg: "Mild warmth on the tongue." },
        { min: 4, max: 6, msg: "Decent kick of heat." },
        { min: 7, max: 9, msg: "SPICY! Your mouth is on fire." },
        { min: 10, max: 12, msg: "EXTREME HEAT. Pain and pleasure merge." },
        { min: 13, max: Infinity, msg: "VOLCANIC INFERNO. You see through time." },
    ],
    temperature: [
        { min: -Infinity, max: -1, msg: "ABSOLUTE ZERO. Reality freezes around it." },
        { min: 0, max: 1, msg: "Frozen solid. Ice cold." },
        { min: 2, max: 3, msg: "Chilled and refreshing." },
        { min: 4, max: 6, msg: null }, // Room temp, no comment
        { min: 7, max: 8, msg: "Warm and comforting." },
        { min: 9, max: 10, msg: "Hot! Steam rises from it." },
        { min: 11, max: 13, msg: "SCORCHING. Handle with extreme caution." },
        { min: 14, max: Infinity, msg: "INFERNAL TEMPERATURE. It burns just looking at it." },
    ],
    moisture: [
        { min: 0, max: 1, msg: "Bone dry. Dessicated." },
        { min: 2, max: 3, msg: "Quite dry." },
        { min: 4, max: 6, msg: null }, // Normal, no comment
        { min: 7, max: 8, msg: "Moist and juicy." },
        { min: 9, max: 10, msg: "Liquid. Dripping wet." },
    ],
    grease: [
        { min: 0, max: 1, msg: null },
        { min: 2, max: 4, msg: "Slightly oily." },
        { min: 5, max: 7, msg: "Greasy. Leaves residue on fingers." },
        { min: 8, max: 10, msg: "DRIPPING WITH GREASE. Cardiovascular nightmare." },
    ],
    crunch: [
        { min: 0, max: 2, msg: null },
        { min: 3, max: 5, msg: "Slight crunch." },
        { min: 6, max: 8, msg: "Satisfyingly crispy." },
        { min: 9, max: Infinity, msg: "MAXIMUM CRUNCH. Like biting into glass (safely)." },
    ],
    chew: [
        { min: 0, max: 2, msg: null },
        { min: 3, max: 5, msg: "Some chewiness." },
        { min: 6, max: 8, msg: "Chewy. Good jaw workout." },
        { min: 9, max: Infinity, msg: "EXTREMELY CHEWY. Endless mastication." },
    ],
    soft: [
        { min: 0, max: 3, msg: null },
        { min: 4, max: 6, msg: null },
        { min: 7, max: 8, msg: "Soft and pillowy." },
        { min: 9, max: 10, msg: "Melt-in-your-mouth smooth." },
    ],
    filling: [
        { min: -Infinity, max: 0, msg: "Somehow makes you MORE hungry." },
        { min: 1, max: 3, msg: "Light snack." },
        { min: 4, max: 6, msg: "Moderately filling." },
        { min: 7, max: 8, msg: "Very filling. Substantial meal." },
        { min: 9, max: Infinity, msg: "FOOD COMA IMMINENT. Maximum satiation." },
    ],
    energizing: [
        { min: 0, max: 2, msg: null },
        { min: 3, max: 5, msg: "Gives you a little boost." },
        { min: 6, max: 8, msg: "Energizing! You feel alert." },
        { min: 9, max: 12, msg: "WIRED. Sleep is for the weak." },
        { min: 13, max: Infinity, msg: "TRANSCENDENT ENERGY. You vibrate at the atomic level." },
    ],
    calming: [
        { min: -Infinity, max: -3, msg: "Actively stressful. Your cortisol spikes." },
        { min: -2, max: 0, msg: null },
        { min: 1, max: 3, msg: "Slightly soothing." },
        { min: 4, max: 6, msg: "Calming. Tension melts away." },
        { min: 7, max: Infinity, msg: "PROFOUND PEACE. Om." },
    ],
    health: [
        { min: -Infinity, max: -6, msg: "HIGHLY TOXIC. This will kill you." },
        { min: -5, max: -3, msg: "TOXIC. Definitely not safe to eat." },
        { min: -2, max: -1, msg: "Questionable safety. Proceed with caution." },
        { min: 0, max: 3, msg: "Not particularly healthy." },
        { min: 4, max: 6, msg: null }, // Normal, no comment
        { min: 7, max: 8, msg: "Nutritious and wholesome." },
        { min: 9, max: Infinity, msg: "SUPERFOOD. Your cells rejoice." },
    ],
    sanity: [
        { min: -Infinity, max: -10, msg: "ELDRITCH HORROR. Your mind shatters into fragments." },
        { min: -9, max: -5, msg: "SANITY DRAIN. The void whispers back." },
        { min: -4, max: -2, msg: "Unsettling. Something feels deeply wrong." },
        { min: -1, max: 1, msg: null },
        { min: 2, max: 4, msg: "Mentally refreshing." },
        { min: 5, max: Infinity, msg: "SANITY RESTORATION. Reality snaps back into focus." },
    ],
    sadness: [
        { min: 0, max: 2, msg: null },
        { min: 3, max: 5, msg: "Melancholy seeps in." },
        { min: 6, max: 9, msg: "Profound sadness. Tears well up." },
        { min: 10, max: Infinity, msg: "EXISTENTIAL DESPAIR. The weight of existence crushes you." },
    ],
    fear: [
        { min: 0, max: 1, msg: null },
        { min: 2, max: 4, msg: "Slightly unnerving." },
        { min: 5, max: 7, msg: "Fear grips your heart." },
        { min: 8, max: 10, msg: "TERROR. Fight or flight activates." },
        { min: 11, max: Infinity, msg: "PRIMAL HORROR. Every instinct screams RUN." },
    ],
    sentience: [
        { min: 0, max: 0, msg: null },
        { min: 1, max: 2, msg: "...did it just twitch?" },
        { min: 3, max: 5, msg: "It's looking at you. IT KNOWS." },
        { min: 6, max: 8, msg: "The food is ALIVE and AWARE." },
        { min: 9, max: Infinity, msg: "FULLY SENTIENT. It begs for mercy." },
    ],
    radioactivity: [
        { min: 0, max: 1, msg: null },
        { min: 2, max: 4, msg: "Faint glow. Slightly radioactive." },
        { min: 5, max: 7, msg: "RADIOACTIVE. Geiger counter clicking." },
        { min: 8, max: 10, msg: "HIGHLY IRRADIATED. Mutagen levels critical." },
        { min: 11, max: Infinity, msg: "NUCLEAR. You can taste the isotopes." },
    ],
    voidLevel: [
        { min: 0, max: 1, msg: null },
        { min: 2, max: 4, msg: "Touched by the void. Emptiness lingers." },
        { min: 5, max: 8, msg: "VOID-TOUCHED. Reality bends around it." },
        { min: 9, max: 12, msg: "VOID INCARNATE. Existence itself recoils." },
        { min: 13, max: Infinity, msg: "THE ABYSS STARES BACK. You are unmade." },
    ],
    isBurnt: [
        { min: 0, max: 0, msg: null },
        { min: 1, max: Infinity, msg: "BURNT. Charred and blackened." },
    ],
    isRaw: [
        { min: 0, max: 0, msg: null },
        { min: 1, max: Infinity, msg: "RAW. Uncooked." },
    ],
    isVegetarian: [
        { min: 0, max: 0, msg: null },
        { min: 1, max: Infinity, msg: "Vegetarian-friendly." },
    ],
    isVegan: [
        { min: 0, max: 0, msg: null },
        { min: 1, max: Infinity, msg: "Vegan-friendly." },
    ],
    containsGluten: [
        { min: 0, max: 0, msg: null },
        { min: 1, max: Infinity, msg: "Contains gluten." },
    ],
    containsBone: [
        { min: 0, max: 0.2, msg: null },
        { min: 0.21, max: 0.5, msg: "May contain small bones." },
        { min: 0.51, max: Infinity, msg: "Contains bones. Chew carefully." },
    ],
};

// Get feedback message for an attribute value
function getTasteFeedback(attribute, value) {
    const ranges = TASTE_FEEDBACK[attribute];
    if (!ranges) return null;

    for (const range of ranges) {
        if (value >= range.min && value <= range.max) {
            return range.msg;
        }
    }
    return null;
}

// ============================================================================
// DISTANCE CALCULATION & PAYMENT SYSTEM
// ============================================================================

// Attributes used for distance calculation (subset of all attributes)
const DISTANCE_ATTRIBUTES = [
    'savory', 'sweet', 'salty', 'sour', 'bitter', 'spicy',
    'temperature', 'moisture', 'grease', 'crunch', 'chew', 'soft',
    'filling', 'energizing', 'calming', 'health',
    'sanity', 'sadness', 'fear', 'sentience', 'radioactivity', 'voidLevel'
];

// Calculate Euclidean distance between food attributes and customer demand
function calculateDistance(foodAttrs, demandVector) {
    let sumSquares = 0;

    for (const attr of DISTANCE_ATTRIBUTES) {
        const foodVal = foodAttrs[attr] || 0;
        const demandVal = demandVector[attr];

        // Skip attributes not specified in demand (undefined = don't care)
        if (demandVal === undefined) continue;

        const diff = foodVal - demandVal;
        sumSquares += diff * diff;
    }

    return Math.sqrt(sumSquares);
}

// Calculate payment based on distance: 20 * 1.3^(-sqrt(distance))
// Close match = more money, far match = less money
function calculatePayment(distance) {
    const payment = 20 * Math.pow(1.3, -Math.sqrt(distance));
    return Math.max(0, Math.round(payment * 100) / 100); // Round to cents, min $0
}

// Get satisfaction rating based on distance
function getSatisfactionRating(distance) {
    if (distance <= 2) return { rating: "PERFECT", emoji: "★★★★★", color: "#ffff00" };
    if (distance <= 5) return { rating: "EXCELLENT", emoji: "★★★★☆", color: "#33ff33" };
    if (distance <= 10) return { rating: "GOOD", emoji: "★★★☆☆", color: "#33ff33" };
    if (distance <= 20) return { rating: "OKAY", emoji: "★★☆☆☆", color: "#aaffaa" };
    if (distance <= 35) return { rating: "POOR", emoji: "★☆☆☆☆", color: "#ffaa00" };
    return { rating: "TERRIBLE", emoji: "☆☆☆☆☆", color: "#ff3333" };
}

// ============================================================================
// CUSTOMER DEMAND SYSTEM
// Each customer specifies desired attribute ranges (geometry matching)
// ============================================================================

const CUSTOMER_TYPES = [
    // ==================== HUMAN CUSTOMERS (Basic) ====================
    {
        name: "Tired Salaryman",
        hint: "Something filling and salty... I need the energy.",
        avatar: "   O \n  /|\\ \n  / \\",
        demand: { filling: 8, salty: 6, savory: 7, temperature: 7 },
        idealItem: "Beef Bowl", // For reference/hint system
        spawnDay: 1,
    },
    {
        name: "Gym Bro",
        hint: "Pure protein. Cook it. No carbs!",
        avatar: "  _O_ \n \\/|\\/ \n  / \\",
        demand: { savory: 8, filling: 7, chew: 7, temperature: 8, health: 6 },
        idealItem: "Steak",
        spawnDay: 1,
    },
    {
        name: "Sad Student",
        hint: "Just some warm bread... cheap and simple.",
        avatar: "   O \n  /|\\ \n  / \\",
        demand: { temperature: 7, crunch: 6, filling: 3, containsGluten: 1 },
        idealItem: "Toast",
        spawnDay: 1,
    },
    {
        name: "Construction Worker",
        hint: "Meat! In bread! Filling!",
        avatar: "  =O= \n  /|\\ \n  / \\",
        demand: { savory: 7, filling: 8, chew: 6, containsGluten: 1 },
        idealItem: "Burger",
        spawnDay: 1,
    },
    {
        name: "Sushi Fanatic",
        hint: "Fresh fish and rice. Must be RAW. Cold.",
        avatar: "   O \n  <|\\ \n  / \\",
        demand: { savory: 6, temperature: 4, isRaw: 1, health: 7 },
        idealItem: "Sushi",
        spawnDay: 1,
    },
    {
        name: "Health Inspector",
        hint: "Just a glass of water. I'm... inspecting.",
        avatar: "  [O] \n  /|\\ \n  / \\",
        demand: { moisture: 10, health: 8, calming: 2 },
        idealItem: "Water",
        spawnDay: 1,
    },

    // ==================== HUMAN CUSTOMERS (Complex) ====================
    {
        name: "College Student",
        hint: "Cheap noodles in hot soup with egg. Ramen vibes.",
        avatar: "   o \n  /|\\ \n  / \\",
        demand: { savory: 7, filling: 8, moisture: 8, temperature: 8, containsGluten: 1 },
        idealItem: "Ramen",
        spawnDay: 1,
    },
    {
        name: "Italian Chef",
        hint: "Noodles! Tomato sauce! It must be tangy and savory!",
        avatar: "  @O@ \n  /|\\ \n  / \\",
        demand: { savory: 6, sour: 4, filling: 7, temperature: 8, containsGluten: 1 },
        idealItem: "Pasta",
        spawnDay: 1,
    },
    {
        name: "Cheese Lover",
        hint: "Creamy. Cheesy. Comforting. Maximum cheese vibes.",
        avatar: "   O \n <|||> \n  / \\",
        demand: { savory: 7, soft: 8, calming: 5, grease: 5, salty: 5 },
        idealItem: "Mac and Cheese",
        spawnDay: 1,
    },
    {
        name: "Kid",
        hint: "Cheese and bread together! Warm and gooey!",
        avatar: "  ^o^ \n  /|\\ \n  / \\",
        demand: { savory: 6, soft: 7, temperature: 8, calming: 5, isVegetarian: 1 },
        idealItem: "Grilled Cheese",
        spawnDay: 1,
    },
    {
        name: "American Tourist",
        hint: "BURGER! WITH CHEESE! The American dream!",
        avatar: "  $O$ \n  /|\\ \n  / \\",
        demand: { savory: 8, filling: 9, grease: 5, salty: 6 },
        idealItem: "Cheeseburger",
        spawnDay: 1,
    },
    {
        name: "Breakfast Person",
        hint: "Egg on toast. Simple breakfast. Crunchy!",
        avatar: "   O \n -/|\\ \n  / \\",
        demand: { savory: 5, crunch: 6, filling: 5, temperature: 7, isVegetarian: 1 },
        idealItem: "Egg Toast",
        spawnDay: 1,
    },
    {
        name: "Fast Food Fan",
        hint: "Crispy! Salty! Greasy! Fried potato sticks!",
        avatar: "   O \n >/|< \n  / \\",
        demand: { salty: 7, crunch: 8, grease: 7, temperature: 7, isVegan: 1 },
        idealItem: "Salted Fries",
        spawnDay: 1,
    },
    {
        name: "Asian Foodie",
        hint: "Rice fried with egg. Savory and filling.",
        avatar: "   O \n  /|\\~ \n  / \\",
        demand: { savory: 7, filling: 8, grease: 4, temperature: 8, isVegetarian: 1 },
        idealItem: "Egg Fried Rice",
        spawnDay: 1,
    },
    {
        name: "Spice Addict",
        hint: "Sushi but make it HURT. I want SPICY fish!",
        avatar: "  ~O~ \n  /|\\ \n  / \\",
        demand: { spicy: 5, savory: 6, temperature: 4, isRaw: 1 },
        idealItem: "Spicy Sushi",
        spawnDay: 1,
    },
    {
        name: "Coffee Addict",
        hint: "Pure black coffee. BITTER. ENERGIZING. No milk!",
        avatar: "  *O* \n  /|\\ \n  / \\",
        demand: { bitter: 8, energizing: 9, temperature: 8, isVegan: 1 },
        idealItem: "Black Coffee",
        spawnDay: 1,
    },
    {
        name: "Cafe Regular",
        hint: "Coffee with milk. Creamy, mild, not too bitter.",
        avatar: "   O \n ~/|\\ \n  / \\",
        demand: { bitter: 4, energizing: 6, soft: 8, temperature: 7, calming: 2 },
        idealItem: "Latte",
        spawnDay: 1,
    },
    {
        name: "Sweet Tooth",
        hint: "COLD. SWEET. CREAMY. Frozen dessert!",
        avatar: "  ^O^ \n  /|\\ \n  / \\",
        demand: { sweet: 9, soft: 10, temperature: 1, calming: 5 },
        idealItem: "Ice Cream",
        spawnDay: 1,
    },
    {
        name: "Health Nut",
        hint: "Fresh vegetables. Crunchy. HEALTHY. No grease!",
        avatar: "  +O+ \n  /|\\ \n  / \\",
        demand: { crunch: 7, health: 9, isVegan: 1, grease: 0 },
        idealItem: "Salad",
        spawnDay: 1,
    },
    {
        name: "Steak Expert",
        hint: "A proper steak with pepper. Savory. Spicy kick.",
        avatar: "  =O= \n  /|\\ \n  / \\",
        demand: { savory: 9, spicy: 5, filling: 8, chew: 8, temperature: 8 },
        idealItem: "Peppered Steak",
        spawnDay: 1,
    },
    {
        name: "Tea Drinker",
        hint: "Hot tea. Calming. Herbal. Simple pleasure.",
        avatar: "   O \n  /|\\. \n  / \\",
        demand: { calming: 8, temperature: 8, moisture: 9, bitter: 3, isVegan: 1 },
        idealItem: "Tea",
        spawnDay: 1,
    },
    {
        name: "Potato Lover",
        hint: "A warm, fluffy baked potato. Comfort food.",
        avatar: "   O \n  /|\\ \n  / \\",
        demand: { filling: 8, soft: 7, temperature: 8, isVegan: 1, calming: 3 },
        idealItem: "Baked Potato",
        spawnDay: 1,
    },
    {
        name: "Vegetarian",
        hint: "No meat! Something filling and vegetarian!",
        avatar: "   O \n  /|\\ \n  / \\",
        demand: { filling: 6, isVegetarian: 1, health: 6, savory: 5 },
        idealItem: "Egg Rice",
        spawnDay: 1,
    },
    {
        name: "Night Shift Worker",
        hint: "I need ENERGY. Something that will keep me AWAKE.",
        avatar: "  zOz \n  /|\\ \n  / \\",
        demand: { energizing: 8, temperature: 7, bitter: 5 },
        idealItem: "Black Coffee",
        spawnDay: 1,
    },
    {
        name: "Stressed Manager",
        hint: "I need something CALMING. Soothing. Please.",
        avatar: "  @O@ \n  /|\\ \n  / \\",
        demand: { calming: 7, temperature: 8, soft: 7, health: 5 },
        idealItem: "Hot Milk",
        spawnDay: 1,
    },

    // ==================== WEIRD/DANGEROUS CUSTOMERS ====================
    {
        name: "Pyromaniac",
        hint: "I want to eat pure HEAT. BURNING. DANGEROUS.",
        avatar: "  ( ) \n  /|\\ \n  / \\",
        demand: { temperature: 15, spicy: 3, fear: 2, health: -5 },
        idealItem: "Fire",
        spawnDay: 3,  // Requires Amplifier to create Fire
    },
    {
        name: "Chaos Enjoyer",
        hint: "Microwave something! Give me MUTATION! RADIOACTIVE!",
        avatar: "  ?O? \n  /|\\ \n  / \\",
        demand: { radioactivity: 8, savory: 5, sentience: 1 },
        idealItem: "Mystery Meat",
        spawnDay: 4,  // Requires Microwave for radioactive food
    },
    {
        name: "Alien Scout",
        hint: "Zognar requires radioactive swimmer. Many eyes preferred.",
        avatar: "  oOo \n \\/|\\/ \n  / \\",
        demand: { radioactivity: 9, sanity: -3, sentience: 2 },
        idealItem: "Three-Eyed Fish",
        spawnDay: 4,  // Requires Microwave for radioactive food
    },
    {
        name: "Mad Scientist",
        hint: "Irradiated protein! For my experiments!",
        avatar: "  (O) \n  /|\\ \n  / \\",
        demand: { radioactivity: 7, energizing: 3, fear: 1 },
        idealItem: "Glowing Egg",
        spawnDay: 4,  // Requires Microwave for radioactive food
    },
    {
        name: "Void Cultist",
        hint: "I seek the emptiness. The void calls.",
        avatar: "  .O. \n  /|\\ \n  / \\",
        demand: { voidLevel: 8, sanity: -5, fear: 3 },
        idealItem: "Void",
        spawnDay: 1,
    },
    {
        name: "Demon",
        hint: "MEAT. BURNING. SPICY. INFERNAL.",
        avatar: "  >O< \n /|||\\  \n  / \\",
        demand: { spicy: 12, temperature: 14, savory: 6, fear: 3 },
        idealItem: "Inferno Meat",
        spawnDay: 3,  // Requires Amplifier to create Inferno Meat
    },
    {
        name: "Ice Elemental",
        hint: "COLDEST. Absolute zero. Freezing pain.",
        avatar: "  *O* \n  \\|/ \n  / \\",
        demand: { temperature: -5, fear: 4, sanity: -3 },
        idealItem: "Absolute Zero",
        spawnDay: 3,  // Requires Amplifier to create Absolute Zero
    },
    {
        name: "Depression Spirit",
        hint: "Feed me sadness. Amplified despair.",
        avatar: "  _O_ \n  /|\\ \n  / \\",
        demand: { sadness: 15, sanity: -8, calming: -5 },
        idealItem: "Depression",
        spawnDay: 3,  // Requires Amplifier to create Depression
    },
    {
        name: "Eldritch Being",
        hint: "THE ABYSS. INFINITE VOID. EXISTENCE ERASED.",
        avatar: " {oOo} \n \\/|\\/ \n  / \\",
        demand: { voidLevel: 15, sanity: -15, fear: 10 },
        idealItem: "The Abyss",
        spawnDay: 1,
    },
    {
        name: "Fire Demon",
        hint: "Burning grease! Uncontrollable flames!",
        avatar: " \\|O|/ \n  /|\\ \n  / \\",
        demand: { temperature: 15, grease: 10, fear: 6 },
        idealItem: "Grease Fire",
        spawnDay: 3,  // Requires Amplifier to create Fire for Grease Fire
    },
    {
        name: "Salt Miner",
        hint: "PURE SALT. CRYSTALLIZED. MAXIMUM MINERAL.",
        avatar: "  #O# \n  /|\\ \n  / \\",
        demand: { salty: 15, crunch: 10 },
        idealItem: "Salt Crystal",
        spawnDay: 3,  // Requires Amplifier to create Salt Crystal
    },
    {
        name: "Sugar Rush",
        hint: "PURE SUGAR! AMPLIFIED! MAXIMUM SWEETNESS!",
        avatar: "  @O@ \n  /|\\ \n  / \\",
        demand: { sweet: 15, energizing: 10, crunch: 6 },
        idealItem: "Pure Sugar",
        spawnDay: 3,  // Requires Amplifier to create Pure Sugar
    },
    {
        name: "Insomniac",
        hint: "MAXIMUM CAFFEINE. I must NEVER sleep again.",
        avatar: "  !O! \n  /|\\ \n  / \\",
        demand: { energizing: 15, bitter: 10, temperature: 8 },
        idealItem: "Espresso Shot",
        spawnDay: 3,  // Requires Amplifier to create Espresso Shot
    },
    {
        name: "Fear Eater",
        hint: "I consume terror. Pure, paralyzing fear.",
        avatar: "  XOX \n  /|\\ \n  / \\",
        demand: { fear: 15, sanity: -10, energizing: 8 },
        idealItem: "Terror",
        spawnDay: 3,  // Requires Amplifier to create Terror
    },
    {
        name: "Crispy Connoisseur",
        hint: "CRUNCH! Maximum crispy! I want it loud!",
        avatar: "  CCC \n  /|\\ \n  / \\",
        demand: { crunch: 9, salty: 5, temperature: 7 },
        idealItem: "Salted Fries",
        spawnDay: 1,
    },
    {
        name: "Greasy Gus",
        hint: "Oil! Grease! The more the better!",
        avatar: "  OOO \n  /|\\ \n  / \\",
        demand: { grease: 8, savory: 6, filling: 6, temperature: 8 },
        idealItem: "Fried Meat",
        spawnDay: 1,
    },
    {
        name: "The Bitter One",
        hint: "Bitter. Everything must be BITTER.",
        avatar: "  >:( \n  /|\\ \n  / \\",
        demand: { bitter: 9, sweet: 0, energizing: 6 },
        idealItem: "Black Coffee",
        spawnDay: 1,
    },
    {
        name: "Sentient Seeker",
        hint: "I want food that THINKS. That KNOWS.",
        avatar: "  ??? \n  /|\\ \n  / \\",
        demand: { sentience: 8, sanity: -4, fear: 3 },
        idealItem: "Sentient Cheese",
        spawnDay: 4,  // Requires Microwave for Sentient Cheese
    },
];

// ============================================================================
// APPLIANCE UNLOCK SYSTEM
// Appliances become available progressively as days advance
// ============================================================================

const APPLIANCE_UNLOCK_DAYS = {
    fridge: 1,
    pan: 1,
    trash: 1,
    board: 2,
    amp: 3,
    micro: 4
};

class Game {
    constructor() {
        this.money = 50;
        this.sanity = 100;
        this.day = 1;
        this.rent = 20;

        this.customersPerDay = 3;
        this.customersServedCount = 0;
        this.isDayActive = true;

        this.countertop = [];
        this.selectedIndices = [];

        // Initialize the ingredient deck with 6 random basic ingredients
        this.availableIngredients = [];
        this.ingredientCosts = {};  // Track cost of each ingredient
        this.initializeIngredientDeck();

        this.log("DAY 1 INITIALIZED.");
        this.log("RENT DUE END OF SHIFT: $" + this.rent);

        this.customer = null;
        this.nextCustomer();
    }

    // Randomly select 6 ingredients from the 24 basic ATOMS for this run
    initializeIngredientDeck() {
        const shuffled = [...ATOMS].sort(() => Math.random() - 0.5);
        this.availableIngredients = shuffled.slice(0, 6);
        // Set $1 cost for each basic atom ingredient
        this.availableIngredients.forEach(atom => {
            this.ingredientCosts[atom] = 1;
        });
        const stockList = this.availableIngredients.map(a => `${a} ($1)`).join(", ");
        this.log("FRIDGE STOCKED WITH: " + stockList, "system");
    }

    // Get the cost of an ingredient (returns 1 for unknown items)
    getIngredientCost(item) {
        return this.ingredientCosts[item] || 1;
    }

    // Add a newly crafted item to available ingredients with cost tracking
    unlockIngredient(item, cost) {
        if (!this.availableIngredients.includes(item)) {
            // New item - add it with its cost
            this.availableIngredients.push(item);
            this.ingredientCosts[item] = cost;
            this.log(`NEW RECIPE UNLOCKED: ${item} ($${cost}) now available in Fridge!`, "system");
        } else if (cost < this.ingredientCosts[item]) {
            // Cheaper recipe found!
            const oldCost = this.ingredientCosts[item];
            this.ingredientCosts[item] = cost;
            this.log(`CHEAPER RECIPE FOR ${item.toUpperCase()} UNLOCKED! $${oldCost} -> $${cost}`, "system");
        }
    }

    // Check if an appliance is unlocked based on current day
    isApplianceUnlocked(appliance) {
        return this.day >= APPLIANCE_UNLOCK_DAYS[appliance];
    }

    // Update appliance button visibility based on current day
    updateApplianceButtons() {
        const appliances = ['fridge', 'pan', 'board', 'amp', 'micro', 'trash'];
        appliances.forEach(appliance => {
            const btn = document.getElementById(`btn-${appliance}`);
            if (btn) {
                if (this.isApplianceUnlocked(appliance)) {
                    btn.style.display = '';
                } else {
                    btn.style.display = 'none';
                }
            }
        });
    }

    log(msg, type="neutral") {
        const panel = document.getElementById('log-panel');
        const div = document.createElement('div');
        div.textContent = "> " + msg;
        if(type === "error") div.style.color = "#ff3333";
        if(type === "design") div.className = "design-alert";
        if(type === "system") div.style.color = "#ffff00";
        panel.appendChild(div);
        panel.scrollTop = panel.scrollHeight;
    }

    nextCustomer() {
        if (!this.isDayActive) return;

        // Check if this is the final customer of Day 5 (Gordon G boss fight)
        if (this.day === 5 && this.customersServedCount === this.customersPerDay - 1) {
            this.spawnGordonG();
            return;
        }

        // Filter customers by spawnDay (only show customers whose spawnDay <= current day)
        const availableCustomers = CUSTOMER_TYPES.filter(c => (c.spawnDay || 1) <= this.day);
        const template = availableCustomers[Math.floor(Math.random() * availableCustomers.length)];
        this.customer = { ...template };

        document.getElementById('customer-name').textContent = this.customer.name;
        document.getElementById('customer-quote').textContent = this.customer.hint;
        document.getElementById('customer-avatar').textContent = this.customer.avatar;

        // Show key demanded attributes as hints
        const demandHints = this.getDemandHints(this.customer.demand);
        document.getElementById('customer-order').textContent = demandHints;

        this.log(`CUSTOMER ARRIVED: ${this.customer.name}`);
        this.log(`They want: ${demandHints}`);
        this.render();
    }

    // Generate readable hints from demand vector
    getDemandHints(demand) {
        const hints = [];
        const attrDescriptions = {
            savory: "savory",
            sweet: "sweet",
            salty: "salty",
            sour: "sour",
            bitter: "bitter",
            spicy: "spicy",
            temperature: val => val <= 2 ? "FROZEN" : val <= 4 ? "cold" : val >= 12 ? "INFERNAL" : val >= 9 ? "hot" : val >= 7 ? "warm" : null,
            moisture: val => val >= 9 ? "liquid" : val <= 2 ? "dry" : null,
            grease: val => val >= 6 ? "greasy" : val === 0 ? "no grease" : null,
            crunch: val => val >= 6 ? "crunchy" : null,
            chew: val => val >= 7 ? "chewy" : null,
            soft: val => val >= 8 ? "soft" : null,
            filling: val => val >= 7 ? "filling" : val <= 3 ? "light" : null,
            energizing: val => val >= 6 ? "energizing" : null,
            calming: val => val >= 5 ? "calming" : val < 0 ? "stressful" : null,
            health: val => val >= 7 ? "healthy" : val <= 0 ? "toxic" : null,
            sanity: val => val <= -5 ? "SANITY-DRAINING" : val >= 3 ? "sanity-restoring" : null,
            sadness: val => val >= 5 ? "depressing" : null,
            fear: val => val >= 5 ? "terrifying" : null,
            sentience: val => val >= 3 ? "SENTIENT" : null,
            radioactivity: val => val >= 5 ? "RADIOACTIVE" : null,
            voidLevel: val => val >= 5 ? "VOID-TOUCHED" : null,
            isVegetarian: val => val >= 1 ? "vegetarian" : null,
            isVegan: val => val >= 1 ? "vegan" : null,
            isRaw: val => val >= 1 ? "RAW" : null,
            isBurnt: val => val >= 1 ? "burnt" : null,
            containsGluten: val => val >= 1 ? "with gluten" : null,
        };

        for (const [attr, val] of Object.entries(demand)) {
            const desc = attrDescriptions[attr];
            if (desc) {
                if (typeof desc === 'function') {
                    const result = desc(val);
                    if (result) hints.push(result);
                } else if (val >= 5) {
                    hints.push(desc.toUpperCase());
                } else if (val >= 3) {
                    hints.push(desc);
                }
            }
        }

        return hints.length > 0 ? hints.join(", ") : "???";
    }

    spawnGordonG() {
        this.customer = {
            name: "Gordon G. Scowling",
            isBoss: true,
            coursesRequired: 3,
            coursesServed: 0,
            orders: [
                {
                    name: "Appetizer",
                    hint: "A PROPER salad! Fresh, crunchy, with oil dressing. HEALTHY!",
                    demand: { crunch: 6, sour: 4, grease: 4, health: 8, isVegan: 1 },
                    idealItem: "Dressed Salad",
                    maxDistance: 8, // Boss has stricter requirements
                },
                {
                    name: "Main Course",
                    hint: "The ULTIMATE beef bowl! Savory, filling, with EGG! PERFECTION!",
                    demand: { savory: 9, salty: 6, filling: 10, temperature: 8, calming: 4 },
                    idealItem: "Deluxe Beef Bowl",
                    maxDistance: 8,
                },
                {
                    name: "Dessert",
                    hint: "A chocolate shake! COLD. SWEET. CREAMY. ICE COLD!",
                    demand: { sweet: 9, soft: 10, moisture: 8, temperature: 1, calming: 4 },
                    idealItem: "Chocolate Shake",
                    maxDistance: 8,
                }
            ],
            currentCourse: 0,
            avatar: `  [G]
 <|||>
  /|\\
  / \\`
        };

        this.log("======================", "system");
        this.log("BOSS CUSTOMER ARRIVED!", "system");
        this.log("GORDON G. SCOWLING - FOOD CRITIC", "system");
        this.log("======================", "system");
        this.log("He demands a 3-COURSE MEAL!", "design");
        this.log("His standards are IMPOSSIBLY HIGH!", "design");
        this.log("Match his demands closely or face his WRATH!", "design");

        this.updateGordonDisplay();
    }

    updateGordonDisplay() {
        document.getElementById('customer-name').textContent = this.customer.name + " [BOSS]";
        document.getElementById('customer-avatar').textContent = this.customer.avatar;
        
        const currentOrder = this.customer.orders[this.customer.currentCourse];
        document.getElementById('customer-quote').textContent = currentOrder.hint;
        document.getElementById('customer-order').textContent = `Course ${this.customer.currentCourse + 1}/3: ???`;
        
        this.render();
    }

    // --- Actions ---

    useFridge() {
        if (!this.isDayActive) return;
        const modal = document.getElementById('fridge-modal');
        const list = document.getElementById('fridge-items');
        list.innerHTML = "";

        // Show only available ingredients (6 random starting + unlocked recipes) with costs
        this.availableIngredients.forEach(item => {
            const cost = this.getIngredientCost(item);
            const btn = document.createElement('button');
            btn.className = "btn";
            btn.textContent = `${item} ($${cost})`;
            // Grey out if player can't afford
            if (this.money < cost) {
                btn.style.opacity = "0.5";
                btn.style.cursor = "not-allowed";
            }
            btn.onclick = () => {
                this.withdrawItem(item);
            };
            list.appendChild(btn);
        });

        modal.classList.remove('hidden');
    }

    closeFridge() {
        document.getElementById('fridge-modal').classList.add('hidden');
    }

    withdrawItem(item) {
        if (this.countertop.length >= 8) {
            this.log("Countertop is full!", "error");
            this.closeFridge();
            return;
        }

        const cost = this.getIngredientCost(item);

        // Check if player can afford it
        if (this.money < cost) {
            this.log(`Cannot afford ${item} ($${cost})! You have $${this.money}.`, "error");
            this.closeFridge();
            return;
        }

        // Deduct cost and add to countertop
        this.money -= cost;
        this.countertop.push(item);
        this.log(`Withdrew ${item} from Fridge. -$${cost}`);
        this.render();
        this.closeFridge();
    }

    usePan() {
        if (!this.isDayActive) return;
        if (this.selectedIndices.length !== 2) {
            this.log("PAN requires exactly 2 items selected.", "error");
            return;
        }

        const item1 = this.countertop[this.selectedIndices[0]];
        const item2 = this.countertop[this.selectedIndices[1]];
        const key = item1 + "+" + item2;

        // Calculate crafting cost as sum of ingredient costs
        const cost1 = this.getIngredientCost(item1);
        const cost2 = this.getIngredientCost(item2);
        const totalCost = cost1 + cost2;

        let result = RECIPES[key];

        if (!result) {
            result = "Burnt Slop";
            this.log(`Failed Combo: ${item1} + ${item2} = ${result}`, "error");
        } else {
            this.log(`Cooking: ${item1} ($${cost1}) + ${item2} ($${cost2}) -> ${result} ($${totalCost})`);
            // Unlock the newly crafted food for this run with its cost
            this.unlockIngredient(result, totalCost);
        }

        this.selectedIndices.sort((a,b) => b-a);
        this.countertop.splice(this.selectedIndices[0], 1);
        this.countertop.splice(this.selectedIndices[1], 1);
        this.countertop.push(result);
        this.clearSelection();
        this.render();
    }

    useBoard() {
        if (!this.isDayActive) return;
        if (this.selectedIndices.length !== 1) {
            this.log("CHOPPING BOARD requires 1 item selected.", "error");
            return;
        }

        const item = this.countertop[this.selectedIndices[0]];
        
        let ingredients = null;
        for (let [key, val] of Object.entries(RECIPES)) {
            if (val === item && key.includes("+")) {
                ingredients = key.split("+");
                break;
            }
        }

        if (ingredients) {
            this.log(`Chopping: ${item} -> ${ingredients[0]} + ${ingredients[1]}`);
            this.countertop.splice(this.selectedIndices[0], 1);
            this.countertop.push(ingredients[0]);
            this.countertop.push(ingredients[1]);
        } else {
            this.log(`Cannot split ${item}. It is atomic or generic.`, "error");
        }
        this.clearSelection();
        this.render();
    }

    useAmp() {
        if (!this.isDayActive) return;
        if (this.selectedIndices.length !== 1) {
            this.log("AMPLIFIER requires 1 item.", "error");
            return;
        }
        const item = this.countertop[this.selectedIndices[0]];
        const itemCost = this.getIngredientCost(item);

        // Check if amplification recipe exists
        if (RECIPES[item] && !item.includes("+")) {
            const result = RECIPES[item];
            this.countertop[this.selectedIndices[0]] = result;
            this.log(`Amplified ${item} ($${itemCost}) into ${result} ($${itemCost})!`);
            // Unlock the amplified item for this run (same cost as input)
            this.unlockIngredient(result, itemCost);
        } else {
            this.log("Nothing happened. Item cannot be amplified.", "error");
        }

        this.clearSelection();
        this.render();
    }

    useMicrowave() {
        if (!this.isDayActive) return;
        if (this.selectedIndices.length !== 1) {
            this.log("MICROWAVE requires 1 item.", "error");
            return;
        }
        const item = this.countertop[this.selectedIndices[0]];
        const itemCost = this.getIngredientCost(item);
        const chance = Math.random();

        this.countertop.splice(this.selectedIndices[0], 1);

        let result;
        // Check if specific mutation exists
        if (RECIPES[item] && (item === "Meat" || item === "Fish" || item === "Egg" || item === "Potato" || item === "Cheese")) {
            result = RECIPES[item];
            this.log(`Microwave mutated ${item} ($${itemCost}) into ${result} ($${itemCost})!`);
            this.countertop.push(result);
            // Unlock the mutated item for this run (same cost as input)
            this.unlockIngredient(result, itemCost);
        } else if (chance > 0.7) {
            result = "Radioactive Slime";
            this.log(`Microwave mutated ${item} ($${itemCost}) into: RADIOACTIVE SLIME ($${itemCost})`, "error");
            this.countertop.push(result);
            // Unlock radioactive slime for this run
            this.unlockIngredient(result, itemCost);
        } else {
            result = "Hot " + item;
            this.log(`Microwave made ${item} ($${itemCost}) really hot -> ${result} ($${itemCost})`);
            this.countertop.push(result);
            // Unlock the hot variant for this run
            this.unlockIngredient(result, itemCost);
        }
        this.clearSelection();
        this.render();
    }

    useTrash() {
        if (!this.isDayActive) return;
        if (this.selectedIndices.length === 0) return;
        this.selectedIndices.sort((a,b) => b-a);
        this.selectedIndices.forEach(idx => {
            this.log(`Trashed ${this.countertop[idx]}`);
            this.countertop.splice(idx, 1);
        });
        this.clearSelection();
        this.render();
    }

    tasteTest() {
        if (!this.isDayActive) return;
        if (this.selectedIndices.length !== 1) {
            this.log("Select 1 item to taste.", "error");
            return;
        }
        const item = this.countertop[this.selectedIndices[0]];
        this.sanity -= 10;

        // Get food attributes
        const attrs = getFoodAttributes(item);

        this.log(`═══ TASTING '${item.toUpperCase()}' ═══`, "system");

        // Collect all feedback messages
        const feedbackCategories = {
            "FLAVOR": ['savory', 'sweet', 'salty', 'sour', 'bitter', 'spicy'],
            "TEXTURE": ['temperature', 'moisture', 'grease', 'crunch', 'chew', 'soft'],
            "EFFECT": ['filling', 'energizing', 'calming', 'health'],
            "COSMIC": ['sanity', 'sadness', 'fear', 'sentience', 'radioactivity', 'voidLevel'],
            "FLAGS": ['isBurnt', 'isRaw', 'isVegetarian', 'isVegan', 'containsGluten', 'containsBone'],
        };

        let hasOutput = false;

        for (const [category, attributes] of Object.entries(feedbackCategories)) {
            const messages = [];

            for (const attr of attributes) {
                const value = attrs[attr];
                if (value !== undefined) {
                    const feedback = getTasteFeedback(attr, value);
                    if (feedback) {
                        messages.push(feedback);
                    }
                }
            }

            if (messages.length > 0) {
                // Determine log type based on category
                let logType = "neutral";
                if (category === "COSMIC") logType = "design";
                if (category === "EFFECT" && messages.some(m => m.includes("TOXIC") || m.includes("SANITY"))) {
                    logType = "error";
                }

                this.log(`${category}: ${messages.join(" ")}`, logType);
                hasOutput = true;
            }
        }

        if (!hasOutput) {
            this.log("ANALYSIS: Unremarkable. No distinctive traits detected.");
        }

        this.log("═══════════════════════════════════", "system");

        // Apply sanity damage from the food itself if it has negative sanity
        if (attrs.sanity < 0) {
            const sanityDamage = Math.abs(Math.floor(attrs.sanity));
            this.sanity -= sanityDamage;
            this.log(`The taste damages your sanity! (-${sanityDamage} additional)`, "error");
        }

        if (this.sanity <= 0) {
            this.gameOver("SANITY DEPLETED");
            return;
        }

        if (this.sanity <= 30) {
            this.log("Reality distorting... (Sanity Critical!)", "design");
        } else if (this.sanity <= 50) {
            this.log("Vision blurring... (Sanity Low)", "design");
        }

        this.render();
    }

    serveCustomer() {
        if (!this.isDayActive) return;
        if (this.selectedIndices.length !== 1) {
            this.log("Select 1 dish to serve.", "error");
            return;
        }
        const item = this.countertop[this.selectedIndices[0]];

        // Special handling for Gordon G boss battle
        if (this.customer.isBoss) {
            this.serveGordonG(item);
            return;
        }

        this.log(`═══ SERVING ${item.toUpperCase()} ═══`, "system");

        // Get food attributes and customer demand
        const foodAttrs = getFoodAttributes(item);
        const demandVector = this.customer.demand;

        // Calculate Euclidean distance
        const distance = calculateDistance(foodAttrs, demandVector);
        const payment = calculatePayment(distance);
        const satisfaction = getSatisfactionRating(distance);

        // Show what the customer wanted
        const orderHints = this.getDemandHints(demandVector);
        this.log(`Order: ${orderHints}`);

        this.log(`${this.customer.name} examines the ${item}...`);

        // Customer reaction based on satisfaction
        let comment;
        if (satisfaction.rating === "PERFECT") {
            comment = "PERFECT! This is EXACTLY what I wanted!";
        } else if (satisfaction.rating === "EXCELLENT") {
            comment = "Wonderful! This is great!";
        } else if (satisfaction.rating === "GOOD") {
            comment = "This is pretty good, thanks!";
        } else if (satisfaction.rating === "OKAY") {
            comment = "Hmm... not quite what I imagined, but okay.";
        } else if (satisfaction.rating === "POOR") {
            comment = "This isn't really what I asked for...";
        } else {
            comment = "What IS this?! This is NOTHING like what I wanted!";
        }
        this.log(`Comment: "${comment}"`);

        this.log(`Rating: ${satisfaction.emoji} ${satisfaction.rating}`);

        if (payment >= 1) {
            this.money += Math.floor(payment);
            this.log(`Received $${Math.floor(payment)}.`, "system");
        } else if (payment > 0) {
            this.log(`Customer left a few cents. ($${payment.toFixed(2)})`);
        } else {
            this.log("Customer refused to pay.", "error");
        }

        this.log("═══════════════════════════════════", "system");

        this.countertop.splice(this.selectedIndices[0], 1);
        this.clearSelection();

        this.customersServedCount++;
        this.render();

        if (this.customersServedCount >= this.customersPerDay) {
            this.endDay();
        } else {
            setTimeout(() => {
                this.nextCustomer();
            }, 1500);
        }
    }

    // Show comparison between food attributes and customer demand
    showAttributeComparison(foodAttrs, demandVector) {
        const comparisons = [];

        for (const [attr, demandVal] of Object.entries(demandVector)) {
            const foodVal = foodAttrs[attr] || 0;
            const diff = foodVal - demandVal;

            // Create readable attribute name
            const attrName = attr.replace(/([A-Z])/g, ' $1').toLowerCase();

            if (Math.abs(diff) <= 1) {
                comparisons.push({ attr: attrName, status: "match", diff });
            } else if (diff > 0) {
                comparisons.push({ attr: attrName, status: "high", diff });
            } else {
                comparisons.push({ attr: attrName, status: "low", diff });
            }
        }

        // Show a summary of matches and mismatches
        const matches = comparisons.filter(c => c.status === "match");
        const highs = comparisons.filter(c => c.status === "high");
        const lows = comparisons.filter(c => c.status === "low");

        if (matches.length > 0) {
            this.log(`  [OK] ${matches.map(c => c.attr).join(", ")}`);
        }
        if (highs.length > 0) {
            const highMsgs = highs.map(c => `${c.attr} (+${c.diff.toFixed(0)})`);
            this.log(`  [HIGH] ${highMsgs.join(", ")}`, "design");
        }
        if (lows.length > 0) {
            const lowMsgs = lows.map(c => `${c.attr} (${c.diff.toFixed(0)})`);
            this.log(`  [LOW] ${lowMsgs.join(", ")}`, "error");
        }
    }

    serveGordonG(item) {
        const currentOrder = this.customer.orders[this.customer.currentCourse];

        this.log(`═══ SERVING ${item.toUpperCase()} AS ${currentOrder.name.toUpperCase()} ═══`, "system");

        // Get food attributes and boss demand
        const foodAttrs = getFoodAttributes(item);
        const demandVector = currentOrder.demand;

        // Calculate Euclidean distance
        const distance = calculateDistance(foodAttrs, demandVector);
        const satisfaction = getSatisfactionRating(distance);

        // Show what the boss wanted
        const orderHints = this.getDemandHints(demandVector);
        this.log(`Order: ${orderHints}`);

        this.log(`Gordon G. scrutinizes the ${item} intensely...`);

        // Boss has strict requirements - must be within maxDistance
        if (distance <= currentOrder.maxDistance) {
            // Calculate bonus based on how close the match was
            const baseBonus = 25;
            const perfectBonus = distance <= 3 ? 15 : (distance <= 5 ? 10 : 5);
            const totalBonus = baseBonus + perfectBonus;

            let comment;
            if (distance <= 3) {
                comment = `MAGNIFICENT! This ${currentOrder.name} is PERFECT!`;
            } else if (distance <= 5) {
                comment = `Excellent work. This ${currentOrder.name} meets my high standards.`;
            } else {
                comment = `Acceptable. This ${currentOrder.name} will do.`;
            }
            this.log(`Comment: "${comment}"`, "system");

            this.log(`Rating: ${satisfaction.emoji} ${satisfaction.rating}`);
            this.money += totalBonus;
            this.log(`Received $${totalBonus}.`, "system");

            this.customer.currentCourse++;
            this.customer.coursesServed++;

            // Remove served item
            this.countertop.splice(this.selectedIndices[0], 1);
            this.clearSelection();
            this.render();

            // Check if all courses completed
            if (this.customer.coursesServed >= this.customer.coursesRequired) {
                setTimeout(() => {
                    this.defeatGordonG();
                }, 1500);
            } else {
                // Move to next course
                setTimeout(() => {
                    this.log(`═══════════════════════════════════`, "system");
                    this.log(`Next course: ${this.customer.orders[this.customer.currentCourse].name}`, "system");
                    this.updateGordonDisplay();
                }, 1500);
            }
        } else {
            // Distance too high - GAME OVER
            this.log(`Comment: "DISGRACEFUL! This is NOTHING like a proper ${currentOrder.name}!"`, "error");
            this.log(`Rating: ${satisfaction.emoji} ${satisfaction.rating}`, "error");
            this.log("Gordon G smashes his clipboard on the table!", "error");
            this.log("CRITICAL FAILURE - BOSS BATTLE LOST!", "error");

            // Remove item
            this.countertop.splice(this.selectedIndices[0], 1);
            this.clearSelection();
            this.render();

            setTimeout(() => {
                this.gameOver("GORDON G DEFEATED YOU");
            }, 2000);
        }
    }

    defeatGordonG() {
        this.log("======================", "system");
        this.log("GORDON G: 'Magnificent! A perfect 3-course meal!'", "system");
        this.log("GORDON G: 'Your cooking... it's RAW TALENT!'", "system");
        this.log("======================", "system");
        this.log("BOSS DEFEATED!", "system");
        
        this.money += 50; // Boss completion bonus
        this.log("Received $50 BOSS BONUS!");
        
        this.customersServedCount++;
        this.render();
        
        // Show victory screen
        setTimeout(() => {
            this.showVictory();
        }, 2000);
    }

    showVictory() {
        this.isDayActive = false;
        this.log("=== YOU DEFEATED GORDON G! ===", "system");
        
        const panel = document.getElementById('log-panel');
        const victoryDiv = document.createElement('div');
        victoryDiv.className = "game-over";
        victoryDiv.innerHTML = `
            <br>
            =============================<br>
            🌟 VICTORY! 🌟<br>
            =============================<br>
            YOU DEFEATED GORDON G!<br>
            THE FOOD CRITIC HAS BEEN SATISFIED!<br>
            <br>
            FINAL STATS:<br>
            Days Survived: ${this.day}<br>
            Total Money Earned: $${this.money}<br>
            Final Sanity: ${this.sanity}%<br>
            <br>
            =============================<br>
            STAY TUNED FOR THE FULL VERSION<br>
            WITH MORE BOSSES, ALIEN ARCS,<br>
            AND ELDRITCH HORRORS!<br>
            =============================<br>
            <br>
            <button class="btn" onclick="location.reload()">RESTART GAME</button>
        `;
        panel.appendChild(victoryDiv);
    }

    endDay() {
        this.isDayActive = false;
        this.log("=== SHIFT ENDED ===", "system");
        
        if (this.countertop.length > 0) {
            this.log(`Discarded ${this.countertop.length} items from countertop.`);
            this.countertop = [];
        }

        // Sanity Restoration (50% additive, capped at 100)
        const sanityRestore = 50;
        this.sanity = Math.min(100, this.sanity + sanityRestore);
        this.log(`Sanity restored by ${sanityRestore}%. Current: ${this.sanity}%`, "system");

        // Rent Deduction
        this.log(`Deducting Rent: -$${this.rent}`);
        this.money -= this.rent;
        this.render();

        if (this.money < 0) {
            this.gameOver("BANKRUPT");
            return;
        }

        setTimeout(() => {
            this.startNextDay();
        }, 3000);
    }

    startNextDay() {
        this.day++;
        this.customersServedCount = 0;

        // Exponential rent increase (50% per day)
        this.rent = Math.floor(this.rent * 1.5);

        // Difficulty Ramp - more customers
        this.customersPerDay = 3 + Math.floor(this.day / 2);

        this.log(`=== STARTING DAY ${this.day} ===`, "system");
        this.log(`Rent increased to $${this.rent}. Customer Quota: ${this.customersPerDay}`);

        // Announce newly unlocked appliances
        const applianceNames = { board: 'BOARD', amp: 'AMPLIFIER', micro: 'MICROWAVE' };
        for (const [appliance, unlockDay] of Object.entries(APPLIANCE_UNLOCK_DAYS)) {
            if (unlockDay === this.day && applianceNames[appliance]) {
                this.log(`NEW APPLIANCE UNLOCKED: [${applianceNames[appliance]}]!`, "system");
            }
        }
        
        this.isDayActive = true;
        this.render();
        this.nextCustomer();
    }

    gameOver(reason) {
        this.isDayActive = false;
        this.log(`GAME OVER: ${reason}`, "error");
        
        const panel = document.getElementById('log-panel');
        const gameOverDiv = document.createElement('div');
        gameOverDiv.className = "game-over";
        gameOverDiv.innerHTML = `
            <br>
            =============================<br>
            GAME OVER: ${reason}<br>
            DAYS SURVIVED: ${this.day}<br>
            CUSTOMERS SERVED: ${this.customersServedCount + (this.day - 1) * 3}<br>
            =============================<br>
            <button class="btn" onclick="location.reload()">RESTART</button>
        `;
        panel.appendChild(gameOverDiv);
    }

    // --- UI Helpers ---

    toggleSelection(index) {
        if (this.selectedIndices.includes(index)) {
            this.selectedIndices = this.selectedIndices.filter(i => i !== index);
        } else {
            this.selectedIndices.push(index);
        }
        this.render();
    }

    clearSelection() {
        this.selectedIndices = [];
        this.render();
    }

    render() {
        document.getElementById('money').textContent = this.money;

        const sanityDisplay = document.getElementById('sanity');
        sanityDisplay.textContent = this.sanity;
        if (this.sanity <= 30) {
            sanityDisplay.className = "sanity-critical";
        } else {
            sanityDisplay.className = "";
        }

        document.getElementById('day-display').textContent = this.day;
        document.getElementById('rent-display').textContent = this.rent;

        // Update appliance visibility based on day
        this.updateApplianceButtons();

        const percentage = (this.customersServedCount / this.customersPerDay) * 100;
        document.getElementById('progress-bar').style.width = percentage + "%";
        document.getElementById('progress-text').textContent = 
            `SHIFT PROGRESS: ${this.customersServedCount} / ${this.customersPerDay}`;

        const list = document.getElementById('countertop-list');
        list.innerHTML = "";
        this.countertop.forEach((item, index) => {
            const div = document.createElement('div');
            div.className = "item-slot" + (this.selectedIndices.includes(index) ? " selected" : "");
            div.textContent = `[${index + 1}] ${item}`;
            div.onclick = () => this.toggleSelection(index);
            list.appendChild(div);
        });

        // Visual effects based on sanity
        if (this.sanity < 20) {
            document.body.style.filter = "sepia(100%) hue-rotate(300deg) blur(2px) saturate(200%)";
        } else if (this.sanity < 50) {
            document.body.style.filter = "sepia(50%) hue-rotate(300deg) blur(1px)";
        } else {
            document.body.style.filter = "none";
        }
    }
}

// Start - Load food data then initialize game
let game;
(async function init() {
    await loadFoodData();
    game = new Game();
})();

</script>
</body>
</html>
